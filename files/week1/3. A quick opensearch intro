A Quick OpenSearch Introduction
A Quick OpenSearch Introduction
Now that we‚Äôve seen a working search demo and we have a working instance of OpenSearch up and running, let‚Äôs try out a few commands to get a feel for how this engine works. After this, we‚Äôll dive deeper into search and its concepts before returning again to OpenSearch at the end of this week‚Äôs content where we will look at tools like Logstash.

Setup
For these examples, we will use the ‚ÄúDev Tools‚Äù application in the OpenSearch Dashboards UI. If you didn‚Äôt set up your Gitpod instance earlier using the class README, please do so now. The Dashboards UI should be located at https://5601-$GITPOD_URL/app/dev_tools#/console (replace $GITPOD_URL throughout all examples with the URL for your running Gitpod workspace.) You should see something similar to:



This console works by typing in simple REST commands and executing them by clicking on the play icon ( ) located in the upper right corner of the left hand console window. You will see your results in the right hand console window. üëÄ Note: If you are having any difficulty getting set up (or if you have any questions as you are reading this week‚Äôs content), please don‚Äôt hesitate to post in our Slack group! The more you ask questions, the more you (and your classmates, and likely us) will learn!

Getting Started
OpenSearch primarily operates in ‚Äúschemaless‚Äù mode, which means we can kick things off without too much pretense, simply by adding content to it and letting the engine ‚Äúdo the right thing‚Äù (more on this later). To see this in action, let‚Äôs add some content, query it and aggregate it.

In your Dev Tools terminal, run the following:

PUT /search_fun_test/_doc/doc_a
{ 
   "title": "Fox and Hounds", 
   "body": "The quick red fox jumped over the lazy brown dogs.", 
   "category": "childrens" 
}

PUT /search_fun_test/_doc/doc_b
{ 
   "title": "Fox wins championship", 
   "body": "Wearing all red, the Fox jumped out to a lead in the race over the Dog.", 
   "category": "sports" 
}

PUT /search_fun_test/_doc/doc_c
{ 
   "title": "Lead Paint Removal", 
   "body": "All lead must be removed from the brown and red paint.", 
   "category": "instructional" 
}

PUT /search_fun_test/_doc/doc_d
{    
   "title": "The Three Little Pigs Revisted", 
   "body": "The big, bad wolf huffed and puffed and blew the house down. The end.", 
   "category": "childrens" 
}
(üëÄ Note: All of these commands are in the file dev_tools_class_example.dev in our Github repository if that is easier to copy and paste from or work with than here. You can run them all at once by selecting all four commands and hitting the run button.)

After running this, you should see something like:



Two things happened when we ran these commands:

OpenSearch automatically created the ‚Äúsearch_fun_test‚Äù index.
We indexed four (4) documents into that index using OpenSearch‚Äôs default indexing process.
Next, let‚Äôs double check that one of our documents actually made it into the index by retrieving it directly:

GET /search_fun_test/_doc/doc_b
(üëÄ Note: you can simply append a line to the end of the console and run just that command by clicking the play button on that line.)

You should see:



Now, let‚Äôs actually execute a search!

GET /search_fun_test/_search?q=dog
You should see:



We retrieved one document, (doc_b) and it has a score of approximately 1.0902805. Hmm? That doesn‚Äôt seem quite right. Our first document (doc_a) also has dogs, shouldn‚Äôt search return that too? The short answer is no, since OpenSearch is taking all words as is and not applying any linguistic transformations to them. The long answer is further down in this week‚Äôs materials and will be fixed by creating field mappings that tell OpenSearch to stem our content. Until then, let‚Äôs try a word that occurs in more than one doc:

    GET _search?q=jumped
This yields:



Much better! As you can see, when we run a query, we get back a lot of information, including things like the total number of results (‚Äúhits‚Äù), the maximum score of any result as well as the results themselves, which include our original source documents, plus some metadata and a score. Most of this should look and feel similar to how you might query a database like MySQL and get back results, other than those ‚Äú_score‚Äù fields (ignoring the other metadata for a moment). That score field is likely why you enrolled in this class and it is the main differentiator between a search engine and all other data stores. We‚Äôll cover it in more depth later in this week‚Äôs materials and into next week, but for now, you can think of that score as a value generated by the engine that tells you how likely a given document matches your query. The higher the score, the better the match.

Let‚Äôs finish up our OpenSearch exploration by adding an aggregation to our query. Try the following:

GET _search
{
  "size": 0,
  "aggs": {
    "CATEGORY": {
      "terms": {
        "field": "category.keyword"
      }
    }
  }
}
This should yield:



A few things to note on aggregations. We‚Äôll cover them more at the end of this week‚Äôs content below.
‚óè In this example we are using a ‚Äúterms‚Äù aggregator. This aggregator takes each unique word in the field and counts how many times it occurs across all documents that matched our search. Take a moment to add some queries and see how it affects the results.
‚óè You may have noticed that we aggregated on a field called ‚Äúcategory.keyword‚Äù but if you look at our original documents earlier in the example we only have a field called ‚Äúcategory‚Äù. This is because OpenSearch, by default, automatically creates several fields and indexes them in different ways. We‚Äôll cover this more below when we discuss Field Mappings.

One last thing before we move on. If, for whatever reason, you want to delete some documents or even the whole index, you can run any of the following commands:

# Delete a document<br>
DELETE search_fun_test/_doc/doc_b

# Delete an Index<br>
DELETE search_fun_test
At this point, you‚Äôve created an index, fetched a document, searched for documents, and run a simple aggregation over some dummy documents. üéâ Let‚Äôs take a step back and expand our view of search by looking at some broader concepts and a tiny bit of theory before we refocus on OpenSearch and tackle our first project. (Pssst‚Ä¶ This is also a good time to post any questions about what we‚Äôve covered so far on Slack.)